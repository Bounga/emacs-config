* Emacs init

Make startup faster by reducing the frequency of garbage collection.
The default is 800 kilobytes. Measured in bytes.

#+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold most-positive-fixnum
          gc-cons-percentage 0.6)

    (add-hook 'emacs-startup-hook
      (lambda ()
        (setq gc-cons-threshold (* 100 1024 1024) ; 100mb
              gc-cons-percentage 0.1
              read-process-output-max (* 1024 1024))))
#+END_SRC

* Load private info if available

Load private info like tokens and credentials from an encrypted file.

#+BEGIN_SRC emacs-lisp
  ;; Load private info if available
  (defvar private/paradox-github-token nil "The token used by Paradox to authenticate requests on Github.")
  (defvar private/org-gcal-client-id nil "The google calendar client id used by org-gcal.")
  (defvar private/org-gcal-client-secret nil "The google calendar client secret used by org-gcal.")
  (defvar private/org-gcal-username nil "The google calendar username used by org-gcal.")
  (let ((credentials (expand-file-name "personal/credentials.el.gpg" user-emacs-directory)))
    (load credentials t))
#+END_SRC

* Packages handling

Add MELPA to available package repositories and bootstrap
~use-package~.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/")
               t)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-always-defer t)
#+END_SRC

Use paradox for complex package search

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :ensure t
    :config
    (setq paradox-github-token private/paradox-github-token
          paradox-automatically-star nil
          paradox-execute-asynchronously t))
#+END_SRC

* Emacs core

This section sets all common core behaviors for Emacs

#+BEGIN_SRC emacs-lisp 
  ;; Prefer UTF-8 as default encoding
  (set-language-environment "UTF-8")

  ;; Disable interlocking
  (setq create-lockfiles nil)

  ;; Save all temporary files in the same directory
  (setq backup-directory-alist `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))

  ;; warn when opening files bigger than 100MB
  (setq large-file-warning-threshold 100000000)

  ;; enable semantic mode to provide more features to modes
  (semantic-mode t)

  ;; clean up obsolete buffers automatically
  (use-package midnight
    :ensure t
    :hook (after-init . midnight-mode))

  ;; use ibuffer rather than list-buffer
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))

  ;; saner regex syntax
  (use-package re-builder
    :ensure t
    :config
    (setq reb-re-syntax 'string))

  ;; ensure bookmarks are saved automatically on every modification
  (use-package bookmark
    :config
    (setq bookmark-save-flag 1))

  ;; avoid annoying alarm bell
  (setq ring-bell-function 'ignore)

  ;; ensure external copy to clipboard is always saved to kill ring
  (setq save-interprogram-paste-before-kill t)
#+END_SRC

Configuration changes made through the customize UI are usually wrote
in init.el. Creating it as a temporary file effectively disables it
(i.e. any changes are session local).

#+BEGIN_SRC emacs-lisp
  (setq custom-file (make-temp-file "emacs-custom"))
#+END_SRC

* OS specific

This section defines useful settings to use Emacs on Mac OS X.

Mainly it ensures that ~PATH~ environment variable is read from shell
on Emacs startup. It also set command key to meta and option to super.
It also release right option key so I can use it to enter special
characters.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (eq system-type 'darwin)
    :ensure t
    :config
    (defvar mac-option-key-is-meta nil)
    (defvar mac-command-key-is-meta t)

    (setq mac-command-modifier 'meta
          mac-option-modifier 'super
          mac-right-option-modifier nil
          exec-path-from-shell-check-startup-files nil)
    :hook (after-init . exec-path-from-shell-initialize))
#+END_SRC

* Calendar

I use calendar pretty often mostly to know which week or day it is. I
like the calendar to start on Monday rather than Sunday. I also like
to have the week number displayed in its own column in front of the
week row.

#+BEGIN_SRC emacs-lisp
  (use-package calendar
    :config
    (setq calendar-week-start-day 1
          calendar-intermonth-text
          '(propertize
            (format "%2d"
                    (car
                     (calendar-iso-from-absolute
                      (calendar-absolute-from-gregorian (list month day year)))))
            'font-lock-face 'font-lock-warning-face)

          calendar-intermonth-header
          (propertize "Wk"
                      'font-lock-face 'font-lock-keyword-face)))
#+END_SRC

Set my position but can't remember whyâ€¦

#+BEGIN_SRC emacs-lisp
  (use-package solar
    :config
    (setq calendar-latitude 50.4
          calendar-longitude 2.8333
          calendar-location-name "Avion, FR"))
#+END_SRC

* UI

This section is dedicated to UI customiation.

I don't need the splash screen on startup, tool bar nor scroll-bar.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)

  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (set-scroll-bar-mode nil)
#+END_SRC

For some reason Emacs sometime asks to answer its question by y / n
and sometime using yes / no. It's annoying so let's make it use y / n
only.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Moving from a window to another one is a pain with default key
bindings. I use ~Windmove~ to ease window movements by using ~shift~
and an arrow key.

#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings)
#+END_SRC

I like dark themes without too much vibrant colors. 

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :demand t
    :config
    (load-theme 'sanityinc-tomorrow-night t))
#+END_SRC

At the moment my font of choice for editing is [[https://sourcefoundry.org/hack/][Hack]].

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family "Hack"
                      :height 130)
#+END_SRC

I prefer to display the cursor as a bar. I also want it to blink for
some seconds when start / stop being active.

#+BEGIN_SRC emacs-lisp
  ;; customize cursor
  (setq-default cursor-type 'bar)
  (blink-cursor-mode 10)
#+END_SRC

By default the theme I'm using doesn't use a lot of contrast for
selected region and I often find myself not being able to say if a
region is marked or not. So let's add more contrast.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'region nil :background "#666")
#+END_SRC

I like to be able to quickly see what time it is so I display it in
the mode line.
 
#+BEGIN_SRC emacs-lisp
  (use-package time
    :hook (after-init . display-time-mode)
    :config
    (setq display-time-24hr-format t
          display-time-default-load-average nil))
#+END_SRC

Make mode line sexier by using Moody, displaying current line and
column and file size indicator.

#+BEGIN_SRC emacs-lisp
  (use-package moody
    :demand t
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode)

    (if (eq system-type 'darwin)
        ;; For NS/Cocoa, fix weird tab separator colors, see
        ;; https://github.com/tarsius/moody/commit/48c6a3610d41373d81fe25ee9aba40f02b5241d1
        (setq moody-slant-function #'moody-slant-apple-rgb)))

  ;; mode line settings
  (column-number-mode t)
  (size-indication-mode t)
#+END_SRC

Highlight current line and make it brighter so it's easier to find.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
  (set-face-background hl-line-face "#373b41")
#+END_SRC

Emacs has a *a lot* of key bindings. It's hard to memorize everything.
By using [[https://github.com/justbur/emacs-which-key][which-key]] you can start a key binding combination and a
menu will show up to list all available key bindings for the given
prefix. It's really awesome.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :hook (after-init . which-key-mode))
#+END_SRC

Mode line can quickly become messy if you're using a lot of minor
modes. There are some minor mode I enable everywhere so I don't need
to know if it's enabled or not. Using ~minions~ allow to show only
some minor modes in the mode line.

#+BEGIN_SRC emacs-lisp
  (use-package minions
    :ensure t
    :demand t
    :after (moody)
    :config
    (setq minions-direct '(projectile-mode
                           artist-mode
                           scroll-all-mode))
    (minions-mode 1))
#+END_SRC

When opening a help window, move to it

#+BEGIN_SRC emacs-lisp
  (setq help-window-select t)
#+END_SRC

Prettifying UI by using icon

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package all-the-icons-ivy
    :ensure t
    :demand t
    :after (ivy)
    :config
    (all-the-icons-ivy-setup))
#+END_SRC

* Versioning

Files versioning is something I deal with on a daily basis. I'm pretty
comfortable with the command-line but Emacs provides such good tools
to handle versioning that I pretty much stopped doing thing using
command-line.

Magit is a porcelain for Git. It offer a nice and clean UI to use git
through Emacs with handy shortcuts. I couldn't live without this now.

Let's enable it and set my default preferences for log command. We'll
also enable GitFlow extension for Magit.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-c g" . magit-status))
    :config
    ;; default settings
    (setq magit-log-arguments (quote ("--graph" "--color" "--decorate" "-n256"))
          magit-completing-read-function 'ivy-completing-read))

  (use-package magit-gitflow
    :ensure t
    :after magit
    :hook (magit-mode . turn-on-magit-gitflow))
#+END_SRC

Easily navigate through versions of the file.

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+END_SRC

To share or save small snippets of code, documentation or thought I
use [[https://gist.github.com][Gist]].

#+BEGIN_SRC emacs-lisp
  (use-package gist
   :ensure t)
#+END_SRC

When I have to deal with merge conflicts my tool of choice is Emacs
again and its ediff package. I don't like the default splitting and
the fact that the command buffer is on another window, let's fix this.

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :config
    (setq ediff-window-setup-function 'ediff-setup-windows-plain
          ediff-split-window-function 'split-window-horizontally))
#+END_SRC

* Programming

This section is dedicated to common programming settings.

I like to use snippets to speed up coding. That's why I use [[https://github.com/joaotavora/yasnippet][YASnippet]]
and it's [[https://github.com/AndreaCrotti/yasnippet-snippets][community driven snippets]]. It's so useful that I enable it
globally and add it to company backends.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :hook (after-init . yas-global-mode)
    :config
    (eval-after-load 'company
      '(push 'company-yasnippet company-backends)))

  (use-package yasnippet-snippets
    :ensure t)
#+END_SRC

I like to lint my code on-the-fly so I know what is not following the
best practices guidelines. This enable flycheck.

I also enable spell checking for comments and ensure that they are
automatically filled.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :hook ((prog-mode . flycheck-mode)
           (prog-mode . flyspell-prog-mode)
           (prog-mode . (lambda ()
                          (setq-local comment-auto-fill-only-comments t)
                          (auto-fill-mode 1)))))
#+END_SRC

Handling matching parentheses, bracket and so on by hand is a pain so
I use [[https://github.com/Fuco1/smartparens][Smartparens]] that deals with parens pairs and tries to be smart
about it.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :config
    (require 'smartparens-config)
    :hook ((after-init . smartparens-global-mode)
           (prog-mode . turn-on-smartparens-strict-mode)
           (web-mode . turn-off-smartparens-strict-mode)
           (markdown-mode . turn-on-smartparens-strict-mode)))
#+END_SRC

When programming it's often useful to know on which line your cursor
is on and to see surrounding line numbers to quickly jump to it.
display-line-numbers-mode does that for us so let's enable it for
prog-mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

I often need to read the API doc of languages, frameworks and libs I
use when programming. I'm also using the awesome [[https://kapeli.com/dash][Dash]] documentation
browser. [[https://github.com/stanaka/dash-at-point][dash-at-point]] allows to search the word at point in Dash and
can also scope the search on the current used language.

#+BEGIN_SRC emacs-lisp
  (use-package dash-at-point
    :ensure t
    :bind (("C-c d" . dash-at-point)
           ("C-c e" . dash-at-point-with-docset)))
#+END_SRC

I like to use keywords like =TODO= or =FIXME= in my code to mark
portion of code that need particular attention in the future. I also
like to be able to easily see it when I browse code. To do this I use
[[https://github.com/lewang/fic-mode][fic-mode]] to highlight those keywords in code.

#+BEGIN_SRC emacs-lisp
  (use-package fic-mode
    :ensure t
    :hook (prog-mode . fic-mode))
#+END_SRC

Tags are a good way to index code and navigate through it easily. I
use [[https://github.com/leoliu/ggtags][ggtags]] to do this.

#+BEGIN_SRC emacs-lisp
  (use-package ggtags
    :ensure t
    :hook (prog-mode . ggtags-mode))
#+END_SRC

Emacs client for LSP to provide IDE-like experience for development.

I use LSP UI for better UI experience. I also prefer Flycheck over Flymake.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :hook (ruby-mode . lsp)
    :commands lsp)

  (use-package company-lsp
    :ensure t
    :after (lsp-mode)
    :commands company-lsp
    :config
    (eval-after-load 'company
      '(push 'company-lsp company-backends)))

  (use-package lsp-ui
    :ensure t
    :after (lsp-mode)
    :commands lsp-ui-mode
    :config
    (setq lsp-prefer-flymake nil))

  (use-package dap-mode
    :ensure t
    :after (lsp-mode)
    :hook lsp-mode)
#+END_SRC

* Lang

This section is dedicated to packages that provide programming
language modes.

** CSS / SCSS / â€¦

I like my CSS to be indented with two spaces.

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :ensure t
    :config
    (setq css-indent-offset 2))
#+END_SRC

Whenever I can I use SCSS / SASS rather than raw CSS since it's really
more flexible and powerful. scss-mode is annoying because it
auto-compile files to CSS on save. Let's disable it.

#+BEGIN_SRC emacs-lisp
  (use-package scss-mode
    :ensure t
    :config
    (setq scss-compile-at-save nil))
#+END_SRC

When writing HTML I like to rely on Emmet to easily generate HTML
structures. I also use it for CSS / SCSS modes.

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :hook ((css-mode . emmet-mode)
           (scss-mode . emmet-mode)))
#+END_SRC

** Elixir

Elixir is a lot of fun and so powerful. It deserves a great
configuration.

#+BEGIN_SRC emacs-lisp
  (use-package elixir-mode
    :ensure t
    :init
    (add-hook 'elixir-mode-hook
            (lambda () (add-hook 'before-save-hook 'elixir-format nil t))))
#+END_SRC

We also enable the *awesome* [[http://alchemist.readthedocs.io/en/latest/][Alchemist]] package which brings Elixir
tooling integration into Emacs. It is ultra-powerful.

#+BEGIN_SRC emacs-lisp
  (use-package alchemist
    :ensure t
    :hook (elixir-mode . alchemist-mode))
#+END_SRC

** JS

I prefer to use js2-mode which is an improved js-mode.

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode "\\.js\\'"
    :config
    (setq js2-basic-offset 2
          js2-bounce-indent-p t))
#+END_SRC

I do edit JSON files from time to time.

#+BEGIN_SRC emacs-lisp
  (use-package json
    :ensure t
    :config
    (setq js-indent-level 2
          json-reformat:indent-width 2))
#+END_SRC

I'm a big fan of Vue.js. I need a mode for it.

#+BEGIN_SRC emacs-lisp
  (use-package vue-mode
    :ensure t)
#+END_SRC

** Markdown

I do use Markdown a lot at work. We write documentation and blog
posts using Markdown.

I ensure ~.text~, ~.markdown~ and ~.md~ files use markdown-mode.

I also prefer to render preview in browser using [[https://marked.js.org/#/README.md#README.md][Marked]] rather than
the built-in parser since it supports GitHub flavored Markdown.

Lists are two spaces indented, unordered lists uses ~-~ prefix and
YAML metadata are enabled so their are ignored on parse.

I also like to auto-fill my Markdown sources.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.text\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode)
           ("\\.md\\'" . markdown-mode))
    :hook (markdown-mode . auto-fill-mode)
    :config
    (setq markdown-command "/usr/local/bin/marked"
          markdown-list-indent-width 2
          markdown-unordered-list-item-prefix "  - "
          markdown-use-pandoc-style-yaml-metadata t
          markdown-fontify-code-blocks-natively t))

#+END_SRC

** Ruby

Ruby is my language of choice for about 15 years now. A lot of great
packages are available to get a powerful integration of Ruby into
Emacs.

I like to enable subword-mode when editing a Ruby file so that I can
move from word to word easily in camel-cased words.

I don't like to deep indent parameters in parentheses so I disable it.
I also don't want ruby-mode to insert encoding magic comment at the
beginning of file when there are non-ascii characters in the buffer
since it's not need in recent version of Ruby.

#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :ensure t
    :hook (ruby-mode . subword-mode)
    :init
    (setq ruby-deep-indent-paren nil
          ruby-insert-encoding-magic-comment nil))
#+END_SRC

To handle the Ruby version I use on a project basis I use Rbenv.
Let's make it use the right Ruby version automatically when I visit a
Ruby file.

#+BEGIN_SRC emacs-lisp
  (use-package rbenv
    :ensure t
    :hook (ruby-mode . rbenv-use-corresponding))
#+END_SRC

Enable [[https://github.com/rejeep/ruby-tools.el][ruby-tools package]] which provides a collection of handy
functions to manipulate strings.

#+BEGIN_SRC emacs-lisp
  (use-package ruby-tools
    :ensure t
    :hook (ruby-mode . ruby-tools-mode))
#+END_SRC

I also use [[https://github.com/nonsequitur/inf-ruby/][inf-ruby]] which provides a REPL buffer connected to a Ruby
subprocess so I can play with my code in an IRB session right from
Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package inf-ruby
    :ensure t
    :hook (ruby-mode . inf-ruby-minor-mode))
#+END_SRC

Documenting code is an important part of a developer work. In Ruby, I
use [[https://yardoc.org][YARD]] to do this. [[https://github.com/pd/yard-mode.el][yard-mode]] provides support for fontifying YARD
tags and directives in ruby comments and also give tips about how to
use a given tag.

#+BEGIN_SRC emacs-lisp
  (use-package yard-mode
    :ensure t
    :hook (ruby-mode . yard-mode))
#+END_SRC

I mainly create web apps using Rails so having a good integration of
it in Projectile is great.

#+BEGIN_SRC emacs-lisp
  (use-package projectile-rails
    :ensure t
    :hook (after-init . projectile-rails-global-mode))
#+END_SRC

Sometimes I want to align assignments which each others, values in
hashes, and more. I use [[https://www.emacswiki.org/emacs/AlignCommands][align package]] to do this.

#+BEGIN_SRC emacs-lisp
  (use-package align
    :ensure t
    :config
    ;; define rules for automatic alignments
    (add-to-list 'align-rules-list
                 '(ruby-comma-delimiter
                   (regexp . ",\\(\\s-*\\)[^# \t\n]")
                   (repeat . t)
                   (modes  . '(ruby-mode))))

    (add-to-list 'align-rules-list
                 '(ruby-hash-literal
                   (regexp . "\\(\\s-*\\)=>\\s-*[^# \t\n]")
                   (group 2 3)
                   (repeat . t)
                   (modes  . '(ruby-mode))))

    (add-to-list 'align-rules-list
                 '(ruby-hash-literal2
                   (regexp . "[a-z0-9]:\\(\\s-*\\)[^# \t\n]")
                   (repeat . t)
                   (modes  . '(ruby-mode))))

    (add-to-list 'align-rules-list
                 '(ruby-assignment-literal
                   (regexp . "\\(\\s-*\\)=\\s-*[^# \t\n]")
                   (repeat . t)
                   (modes  . '(ruby-mode))))

    (add-to-list 'align-rules-list
                 '(ruby-xmpfilter-mark
                   (regexp . "\\(\\s-*\\)# => [^#\t\n]")
                   (repeat . nil)
                   (modes  . '(ruby-mode)))))
#+END_SRC

** HTML

I mostly do web development so HTML is at the heart of what I'm doing.

[[http://web-mode.org][web-mode]] is responsible of editing web templates. It knows about a lot
of template engines. It a full featured mode with everything you can
dream of to edit HTML templates.

I use it for html, handlebars, erb and eex files. It is configured to
auto-close tags. It's also configured to instruct smartparens about
how to handle erb / eex tag pairs.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode (("\\.html?\\'" . web-mode)
           ("\\.erb\\'" . web-mode)
           ("\\.eex\\'" . web-mode))
    :config
    ;; Set indent to 2 and auto-close tags
    (setq web-mode-markup-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-enable-current-element-highlight t
          web-mode-enable-auto-closing t
          web-mode-enable-auto-pairing nil)

    ;; make web-mode play nice with smartparens
    (eval-after-load 'smartparens
      (sp-with-modes '(web-mode)
        (sp-local-pair "%" "%"
                       :unless '(sp-in-string-p)
                       :post-handlers '(((lambda (&rest _ignored)
                                           (just-one-space)
                                           (save-excursion (insert " ")))
                                         "SPC" "=" "#")))
        (sp-local-tag "%" "<% "  " %>")
        (sp-local-tag "=" "<%= " " %>")
        (sp-local-tag "#" "<%# " " %>"))))
#+END_SRC

I also use Slim and Emblem so I use slim-mode for it.

#+BEGIN_SRC emacs-lisp
  (use-package slim-mode
    :ensure t
    :mode (("\\.emblem\\'" . slim-mode)))
#+END_SRC

Another tool I really like to help me is [[http://emmet.io/][Emmet]] which add a set of
abbreviation you can use to quickly write complex [[https://github.com/smihica/emmet-mode#html-abbreviations][HTML]] and [[https://github.com/smihica/emmet-mode#css-abbreviations][CSS]]
structures. I use it through [[https://github.com/smihica/emmet-mode][emmet-mode]].

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :hook (web-mode vue-mode css-mode))
#+END_SRC

* Jekyll

I use Jekyll as my blogging engine. I need to be able to insert
back-links and images in my posts from time to time.

Let's ease this by adding two helpers to do the hard-work for us.

#+BEGIN_SRC emacs-lisp
  (defun jekyll-insert-post-url ()
    (interactive)
    (let* ((files (remove "." (mapcar #'file-name-sans-extension (directory-files "."))))
           (selected-file (completing-read "Select article: " files nil t)))
      (insert (format "{%% post_url %s %%}" selected-file))))

  (defun jekyll-insert-image-url ()
    (interactive)
    (let* ((files (directory-files "../assets/images"))
           (selected-file (completing-read "Select image: " files nil t)))
      (insert (format "![%s](/assets/images/%s)" selected-file selected-file))))
#+END_SRC

* Projectile
 
[[https://projectile.readthedocs.io/en/latest/][Projectile]] is projection interaction library that ease projects
management.

When I switch to a project I like to select a file rather than
starting =dired= in its root folder.

I use =Helm= as completion system and don't want useless directories
such as =tmp=, =.git=, etc being listed in project files.

As I often search for given expression in whole project I want the
search to be fast that why I use [[https://github.com/ggreer/the_silver_searcher][Ag]] and its Helm backend.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :hook (after-init . projectile-mode)
    :config
    (setq projectile-switch-project-action 'projectile-find-file
          projectile-completion-system 'ivy
          projectile-globally-ignored-directories
          (quote
           (".idea" ".eunit" ".git" ".hg" ".fslckout" ".bzr" "_darcs" ".tox" ".svn" ".stack-work" "public/system" "vendor/bundle" "node_modules" "bower_components" ".bundle" ".sass-cache" ".yardoc" "tmp" "_build" "deps"))
          projectile-globally-ignored-file-suffixes (quote ("DS_Store" "log" "pdf"))))

  (use-package ag
    :ensure t)
#+END_SRC

I sometime need to take notes on a given project to remember things to
do or even create issues on the bug tracker. I think /org-projectile/
can help me with that.

#+BEGIN_SRC emacs-lisp
  (use-package org-projectile
    :ensure t
    :after projectile
    :bind (("C-c n p" . org-projectile-project-todo-completing-read))
    :config
    (progn
      (setq org-projectile-projects-file (concat org-directory "/projects.org")
            org-confirm-elisp-link-function nil)
      (push (org-projectile-project-todo-entry) org-capture-templates)))
#+END_SRC

* Dired

When using =Dired= to manipulate directories and files I like to copy
and delete recursively. I also like my =Dired= buffer to be updated
automatically when an external tool modify the directory structure.

File sizes are displayed using human friendly format but such details
are hidden by default for clarity. You can toggle details back by
pressing =(= key.

Deleting a file doesn't remove it from the disk but rather moves it to
the system trash for more safety.

When two dired buffers are opened side-by-side renaming and copying
operations automatically the other buffer directory as the target.

=C-x j= opens the directory of the file in current buffer and move
the cursor on this given file.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :config
    (setq dired-recursive-deletes 'always
          dired-recursive-copies 'always
          dired-auto-revert-buffer t
          dired-listing-switches "-alh"
          dired-dwim-target t
          delete-by-moving-to-trash t)
    (put 'dired-find-alternate-file 'disabled nil)
    :hook (dired-mode . dired-hide-details-mode)
    :bind ("C-x j" . dired-jump))
#+END_SRC

* Tramp

Navigating in directories and editing files on remote hosts can be
done seamlessly by using [[https://www.gnu.org/software/tramp/][Tramp]]. It also allow to sudo edit files as
another user.

I especially like to use it to work on my Raspberry Pi and to manage
my server.

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :config
    ;; ssh access method is faster than default scp one
    (setq tramp-default-method "ssh"))
#+END_SRC

* Editing

This section is dedicated to common editing settings.

I don't like using tabs and prefer to use two spaces for indentation.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq standard-indent 2)
#+END_SRC

I like my text files to end up with a final empty line so command-line
tools works nicely.

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

When text is selected I want it to be overwritten if I type something
or hit delete.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC

By default Emacs think that a sentence ended if there are two spaces
after a dot. I want a sentence to be ended after a dot and one space.
In many cases it's much easier to move in text this way.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

When editing code it's nice to be able to easily see matching
parentheses. This enable parentheses pairs highlighting.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

I'm still not used to it but Emacs has a feature that allow to define
abbreviations that can be used anywhere to speedup typing. This setup
automatically save abbreviations across sessions in
=~/emacs.d/abbrev_defs=.

For now it's enabled only for =text-mode= compatible buffers. Maybe I'll
find a use for it in =prog-mode= someday.

#+BEGIN_SRC emacs-lisp
  (use-package abbrev
    :hook (text-mode . abbrev-mode)
    :config
    (setq abbrev-file-name "~/.emacs.d/abbrev_defs"
          save-abbrevs t))
#+END_SRC

Completion tool is a must-have in a text editor. [[https://company-mode.github.io][Company]] is a powerful
framework that display completion popup.

I set it up to popup quickly as soon as 3 characters were entered and
limit the result popup to 10 results. This mode is enabled globally.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand t
    :config
    (setq company-idle-delay 0.5
          company-tooltip-limit 10
          company-minimum-prefix-length 2
          company-tooltip-align-annotations t)
    (global-company-mode t)

    ;; use C-n / C-p to navigate in popup rather than M-n / M-p
    :bind (:map company-active-map
                ("M-n" . nil)
                ("M-p" . nil)
                ("C-n" . 'company-select-next)
                ("C-p" . 'company-select-previous)))
#+END_SRC

Company comes with a back-end to complete dynamic abbreviations. These
abbreviations are completion of words existing in open buffers.

#+BEGIN_SRC emacs-lisp
  (use-package company-dabbrev
    :init
    (setq company-dabbrev-downcase nil))
#+END_SRC

I often rely on words available in open buffers, file names, kill
ring, abbrev, etc to complete word at point. Hippie-expand seems to be
the most powerful command to do this so let's use it.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol))
#+END_SRC

Sometimes I like to use Emojis. The easiest way to do this is to use
=company-emoji=.

#+BEGIN_SRC emacs-lisp
  (use-package company-emoji
    :after company
    :init
    (add-to-list 'company-backends 'company-emoji)

    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
          ;; For NS/Cocoa
          (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
        ;; For Linux
        (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))
    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    :hook (after-make-frame-functions . --set-emoji-font))
#+END_SRC

Handling white-spaces by hand is a pain. I use [[https://www.emacswiki.org/emacs/WhiteSpace][whitespace]] to cleanup
my buffer on save. It also highlight invisible characters and add a
visual clue if a line is more than 80 characters long.

This minor mode is enabled for =prog-mode= only.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure t
    :hook (after-init . global-whitespace-mode)
    :config
    (setq whitespace-action '(auto-cleanup)
          whitespace-line-column 80
          whitespace-style '(face tabs empty trailing lines-tail)
          whitespace-global-modes '(prog-mode ruby-mode)))
#+END_SRC


When editing a versioned file it is great to know if something
changed. [[https://github.com/dgutov/diff-hl][diff-hl]] highlights changes on the left side of the window,
allows to navigate through hunks and revert them.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :hook ((prog-mode . diff-hl-mode)
           (dired-mode . diff-hl-dired-mode))
    :config
    (global-diff-hl-mode +1))
#+END_SRC

I do *a lot* of typos. [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] helps me by marking mistakes and
providing me a list of potential corrections. 

I use it for text file but also for code where it checks typos in comments.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :hook ((text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode))
    :custom
    (flyspell-issue-message-flag nil)
    (flyspell-issue-welcome-flag nil)
    (ispell-program-name "/usr/local/bin/aspell")
    (ispell-dictionary "american"))

  (use-package flyspell-correct-ivy
    :ensure t
    :after flyspell
    :bind (:map flyspell-mode-map
                ("C-;" . flyspell-correct-previous-word-generic)))
#+END_SRC

Undoing changes when a lot of modifications have been done can be
difficult. [[https://www.emacswiki.org/emacs/UndoTree][Undo Tree]] is a great visual tool to navigate through
changes and change branches.  

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :hook (after-init . global-undo-tree-mode))
#+END_SRC

[[https://github.com/magnars/expand-region.el][Expand region]] helps to easily expand region by semantic units. It
tries to be smart about it and it's really useful.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . er/expand-region)))
#+END_SRC

I often need to duplicate a line to change it a bit. I also often need
to move a given line or region around. [[https://github.com/wyuenho/move-dup][move-dup]] does just that and
does it very well.

#+BEGIN_SRC emacs-lisp
  (use-package move-dup
    :ensure t
    :hook (after-init . global-move-dup-mode))
#+END_SRC

Revert buffers automatically when underlying files are changed
externally.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

Enable erase-buffer command.

#+BEGIN_SRC emacs-lisp
  (put 'erase-buffer 'disabled nil)
#+END_SRC

Enable narrowing functions.

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)
#+END_SRC

* ERC

IRC has always been a great place to ask technical questions and chat
about everything. Emacs comes with [[https://delysid.org/emacs/erc.html][ERC]] which a nice and powerful
client.

#+BEGIN_SRC emacs-lisp
  (use-package erc
    :hook (erc . erc-truncate-mode)
    :config
    (setq erc-prompt-for-password nil
          erc-hide-list '("JOIN" "PART" "QUIT")
          erc-kill-buffer-on-part t
          erc-kill-queries-on-quit t
          erc-kill-server-buffer-on-quit t
          erc-server-coding-system '(utf-8 . utf-8)
          erc-modules
          (quote
           (autojoin button completion fill irccontrols match netsplit networks noncommands notifications readonly ring services smiley stamp track))
          erc-nick "Bounga"
          erc-user-full-name "Nicolas Cavigneaux"
          erc-server "irc.freenode.net"
          erc-autojoin-channels-alist '(("freenode.net"
                                         "#ruby"
                                         "#elixir-lang"
                                         "#emacs"
                                         "#emacsfr"
                                         "#gnus"
                                         "#org-mode"
                                         "#synbioz"))))

  (use-package erc-services
    :config
    (setq erc-prompt-for-nickserv-password nil)
    (erc-services-mode t))

  (use-package erc-spelling
    :config
    (setq erc-spelling-dictionaries '(("irc.freenode.net:6667" "american")
                                      ("#emacsfr" "french")
                                      ("#synbioz" "french")))
    (erc-spelling-mode t))

  (use-package erc-hl-nicks
    :ensure t)
#+END_SRC

* Gnus

Reading emails in text mode is fun ðŸ˜‰. [[http://gnus.org][Gnus]] is incredibly powerful
when it comes to reading News or emails. It does everything you can
dream of and that's why its [[http://gnus.org/manual/gnus_toc.html][manual is so big]].

It even can take care of your favorites [[https://www.gnu.org/software/emacs/manual/html_node/gnus/RSS.html][RSS feeds]].

#+BEGIN_SRC emacs-lisp
  (use-package gnus-start
    :config
    (setq gnus-init-file "~/.emacs.d/gnus.el"
          gnus-startup-file "~/.emacs.d/newsrc"
          gnus-directory "~/.emacs.d/News/"
          message-directory "~/.emacs.d/Mail/"))
#+END_SRC

* News feeds

Subscribing to good news feeds is a nice way to stay up-to-date with
latest things happening. I use Newsticker for this.

#+BEGIN_SRC emacs-lisp
  (setq newsticker-url-list '(("Reddit Emacs" "https://www.reddit.com/r/emacs/.rss" nil 3600)
                              ("Reddit Elixir" "https://www.reddit.com/r/elixir/.rss" nil 3600)
                              ("Reddit Org Mode" "https://www.reddit.com/r/orgmode/.rss" nil 3600)
                              ("Reddit Ruby" "https://www.reddit.com/r/ruby/.rss" nil 3600)))
#+END_SRC

* Smex

It provides a convenient interface to your recently and most
frequently used commands.

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :config
    (smex-initialize))
#+END_SRC

* Ivy

[[https://github.com/abo-abo/swiper][Ivy]] is an Emacs framework for incremental completions and narrowing
selections. It helps to rapidly complete file names, buffer names, or
any other Emacs interactions requiring selecting an item from a list
of possible choices.

I use it for everything everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :bind (("C-c C-r" . ivy-resume)
           ("C-x b" . ivy-switch-buffer))
    :hook (after-init . ivy-mode)
    :config
    (setq ivy-use-virtual-buffers t
          ivy-use-selectable-prompt t
          ivy-wrap t))

  (use-package ivy-rich
    :ensure t
    :after ivy
    :init
    (setcdr (assq t ivy-format-functions-alist)
            #'ivy-format-function-line)
    :hook (ivy-mode . ivy-rich-mode))

  (use-package counsel
    :ensure t
    :bind
    (("C-h a" . counsel-apropos)
     ("C-c f" . counsel-recentf)
     ("C-x c i" . counsel-semantic-or-imenu)
     :map minibuffer-local-map
     ("C-r" . counsel-minibuffer-history)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line))
    :config
    (counsel-mode))

  (use-package counsel-projectile
    :ensure t
    :init
    (eval-after-load 'projectile
      (counsel-projectile-mode)))

  (use-package avy
    :ensure t
    :bind (("C-:" . avy-goto-char)
           ("C-'" . avy-goto-char-2)
           ("M-g g" . avy-goto-line)
           ("M-g w" . avy-goto-word-1)
           ("M-g e" . avy-goto-word-0)
           ("C-c C-j" . avy-resume)))

  (use-package swiper
    :ensure t
    :after ivy
    :config
    (setq swiper-goto-start-of-match t)
    :bind (("C-s" . swiper-isearch)))
#+END_SRC

* Org

[[http://www.orgmode.org][Org-mode]] is an incredibly powerful tool which I use for taking notes,
plan projects, maintain TODO lists, author documents and more.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :bind (("C-c l" . org-store-link)
           ("C-c a" . org-agenda)
           ("C-c b" . org-switchb)
           ("C-c c" . org-capture))
    :hook ((org-mode . turn-on-auto-fill)
           (org-mode . flyspell-mode))
    :config
    (setq org-directory "~/Documents/org"
          org-agenda-files (directory-files org-directory t ".org$")
          org-log-done t
          org-hide-leading-stars t
          org-startup-indented t
          org-default-notes-file (concat org-directory "/notes.org")
          org-enforce-todo-dependencies t
          org-catch-invisible-edits 'error
          org-confirm-babel-evaluate nil
          org-blank-before-new-entry '((heading . always) (plain-list-item . auto))
          org-global-properties '(("Effort_ALL". "0:10 0:20 0:30 1:00 2:00 3:00 4:00 6:00 8:00 0:00"))
          org-columns-default-format '"%38ITEM(Details) %TAGS(Context) %7TODO(To Do) %5Effort(Time){:} %6CLOCKSUM(Clock){:}")

    ;; make tab in source code blocks act the same way as in a native buffer
    (setq org-src-tab-acts-natively t
          org-src-fontify-natively t
          org-src-window-setup 'current-window)

    ;; targets for refiling
    (setq org-refile-targets (quote (
                                     (nil :maxlevel . 2)
                                     (org-agenda-files :maxlevel . 2))))

    ;; load useful babel modes for inline evaluation
    (org-babel-do-load-languages
     (quote org-babel-load-languages)
     (quote ((emacs-lisp . t)
             (elixir . t)
             (ruby . t)
             (css . t)
             (shell . t)
             (org . t)
             (sass . t)
             (latex . t)))))

  ;; Clocking
  (use-package org-clock
    :bind (("<f12> l" . org-clock-in-last)
           ("<f12> o" . org-clock-out)
           ("<f12> g" . org-clock-goto))
    :config
    (setq org-clock-idle-time 10
          org-clock-out-remove-zero-time-clocks t)
    (bind-key "<f12> i" (lambda () (interactive) (org-clock-in '(4)))))

  ;; Capture templates
  (use-package org-capture
    :config
    (setq org-capture-templates
          (quote (("t" "Task" entry (file+headline (lambda () (concat org-directory "/notes.org")) "Tasks")
                   "* TODO %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n" :clock-in t :clock-resume t)
                  ("n" "Note" entry (file+headline (lambda () (concat org-directory "/notes.org")) "Notes")
                   "* %? %^g \n:PROPERTIES:\n:CREATED: %U\n:END:\n" :clock-resume t)
                  ("w" "Work" entry (file+headline (lambda () (concat org-directory "/work.org")) "Tasks")
                   "* TODO %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n" :clock-in t :clock-resume t)
                  ("h" "Home" entry (file+headline (lambda () (concat org-directory "/notes.org")) "Home")
                   "* TODO %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n" :clock-in t :clock-resume t)
                  ("l" "Link" entry (file+headline (lambda () (concat org-directory "/notes.org")) "Links")
                   "* %^L %^g \n:PROPERTIES:\n:CREATED: %U\n:END:\n" :prepend t)
                  ("j" "Journal" entry (file+olp+datetree (lambda () (concat org-directory "/journal.org")))
                   "* %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n\n  %i" :clock-in t :clock-resume t)
                  ("a" "Appointment" entry (file (lambda () (concat org-directory "/gcal.org")))
                   "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")))))

  ;; Custom agenda commands
  (use-package org-agenda
    :config
    (setq org-agenda-include-diary t)
    (add-to-list 'org-agenda-custom-commands
                 '("w" "Work agenda and TODOs"
                   ((agenda)
                    (tags-todo "CATEGORY=\"work\"")
                    )
                   ((org-agenda-category-filter-preset '("+work"))))))

  ;; Exporters
  (use-package ox-gfm
    :ensure t
    :init
    (require 'ox-gfm))

  (use-package ox-twbs
    :ensure t
    :init
    (require 'ox-twbs))

  (use-package ob-elixir
    :ensure t)

  (use-package org-bullets
    :ensure t
    :hook (org-mode . org-bullets-mode))
#+END_SRC

* Shell

emacs-vterm allow to emulate very complex term in an Emacs buffer by
using libvterm. Using vterm I can use Fish, my complex prompt and even
ncurse / interactive programs in a Emacs buffer as if I was using
Terminal.app. I really love it!

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :ensure t)
#+END_SRC

Eshell can be useful when using a shell in Emacs. Let's use [[https://github.com/manateelazycat/aweshell][Aweshell]]
to enhance usage experience.

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :after (exec-path-from-shell)
    :init
    (add-to-list 'load-path (expand-file-name "~/.emacs.d/elisp/aweshell"))
    (require 'aweshell))
#+END_SRC

* PDF

Emacs has built-in support for viewing PDF but is pretty limited in
features. [[https://github.com/politza/pdf-tools][PDF Tools]] provides a much more powerful set of features.

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :hook (after-init . pdf-tools-install))
#+END_SRC

